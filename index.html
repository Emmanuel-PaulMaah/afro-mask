<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Afro Mask</title>
  <style>
    body { margin: 0; }
    canvas { display: block; margin: auto; }
    #controls {
      position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px;
    }
    button {
      margin: 0 5px; padding: 6px 12px;
      background: white; border: none; cursor: pointer; border-radius: 4px;
    }
  </style>
</head>
<body>

<video id="video" autoplay playsinline muted></video>
<canvas id="output"></canvas>

<div id="controls"></div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
  const videoElement = document.getElementById('video');
  const canvasElement = document.getElementById('output');
  const canvasCtx = canvasElement.getContext('2d');
  const controls = document.getElementById('controls');

  // ✅ Masks with their own calibration factors
  const maskConfigs = [
    { src: "assets/mask1.png", scaleW: 1.2, scaleH: 1.6 }, // taller
    { src: "assets/mask2.png", scaleW: 1.4, scaleH: 1.3 }, // wider
    { src: "assets/mask3.png", scaleW: 1.2, scaleH: 1.4 }  // balanced
  ];

  // Preload masks
  const masks = maskConfigs.map(cfg => {
    const img = new Image();
    img.src = cfg.src;
    return { img, ...cfg };
  });

  let currentMaskIndex = 0;

  // Buttons to switch masks
  maskConfigs.forEach((cfg, i) => {
    const btn = document.createElement("button");
    btn.innerText = `Mask ${i+1}`;
    btn.onclick = () => { currentMaskIndex = i; };
    controls.appendChild(btn);
  });

  const faceMesh = new FaceMesh({
    locateFile: (file) => {
      return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
    }
  });

  faceMesh.setOptions({
    maxNumFaces: 1,
    refineLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  faceMesh.onResults((results) => {
    canvasElement.width = videoElement.videoWidth;
    canvasElement.height = videoElement.videoHeight;

    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

    // Draw video
    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
      const landmarks = results.multiFaceLandmarks[0];

      // Reference points
      const leftEar = landmarks[234];
      const rightEar = landmarks[454];
      const nose = landmarks[1];
      const chin = landmarks[152];
      const forehead = landmarks[10];

      const noseX = nose.x * canvasElement.width;
      const noseY = nose.y * canvasElement.height;
      const leftX = leftEar.x * canvasElement.width;
      const leftY = leftEar.y * canvasElement.height;
      const rightX = rightEar.x * canvasElement.width;
      const rightY = rightEar.y * canvasElement.height;
      const chinY = chin.y * canvasElement.height;
      const foreheadY = forehead.y * canvasElement.height;

      // Face dimensions
      const faceWidth = Math.hypot(rightX - leftX, rightY - leftY);
      const faceHeight = Math.abs(chinY - foreheadY);

      // Rotation
      const angle = Math.atan2(rightY - leftY, rightX - leftX);

      // Current mask + calibration
      const { img: maskImg, scaleW, scaleH } = masks[currentMaskIndex];
      if (maskImg.complete) {
        const maskWidth = faceWidth * scaleW;
        const maskHeight = faceHeight * scaleH;

        canvasCtx.translate(noseX, noseY);
        canvasCtx.rotate(angle);
        canvasCtx.drawImage(maskImg, -maskWidth / 2, -maskHeight / 2, maskWidth, maskHeight);
        canvasCtx.rotate(-angle);
        canvasCtx.translate(-noseX, -noseY);
      }
    }
    canvasCtx.restore();
  });

  // ✅ Camera setup with fallback for Android
  try {
    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await faceMesh.send({ image: videoElement });
      },
      width: 640,
      height: 480
    });
    camera.start();
  } catch (err) {
    console.warn("MediaPipe Camera failed, using getUserMedia fallback:", err);
    if (navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          videoElement.srcObject = stream;
          videoElement.onloadedmetadata = () => {
            videoElement.play();
            const loop = async () => {
              await faceMesh.send({ image: videoElement });
              requestAnimationFrame(loop);
            };
            loop();
          };
        })
        .catch(e => console.error("Camera error:", e));
    }
  }
</script>

</body>
</html>
